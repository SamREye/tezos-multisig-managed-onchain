archetype multisig_managed_state(
  owner: address
)

/////////////////////////////////////////////////
// Metadata support
/////////////////////////////////////////////////

entry set_metadata_uri(idata: bytes) {
  called by owner
  effect {
    metadata := put(metadata, "", idata)
  }
}

/////////////////////////////////////////////////
// Multisig
/////////////////////////////////////////////////

states =
| UnInitialized initial
| Running

variable signers: set<address> = []
variable threshold: nat = 0

transition initialize(the_signers: set<address>, the_threshold: nat) {
  called by owner
  from UnInitialized
  to Running
  when {
    0 < the_threshold <= length(the_signers)
  }
  with effect {
    signers := the_signers;
    threshold := the_threshold
  }
}

variable last_op_id: nat = 0
asset pending_ops to big_map {
  op_id: nat;
  expiration: date;
  actions: lambda<unit, list<operation>>;
  approvals: set<address>
}

entry propose(
  the_actions: lambda<unit, list<operation>>,
  the_duration: duration,
  is_caller_approved: bool
) {
  state is Running
  require {
    r01: signers.contains(caller) otherwise "ONLY FOR SIGNERS"
  }
  effect {
    last_op_id += 1;
    pending_ops.add({
      op_id = last_op_id;
      expiration = (now + the_duration);
      actions = the_actions;
      approvals = (is_caller_approved ? make_set<address>([caller]) : make_set<address>([]))
    })
  }
}

entry approve(
  the_op_id: nat
) {
  state is Running
  constant {
    my_pending_op ?is pending_ops[the_op_id] otherwise "INVALID OP ID"
  }
  require {
    r10: signers.contains(caller) otherwise "ONLY FOR SIGNERS";
    r11: not my_pending_op.approvals.contains(caller) otherwise "ALREADY APPROVED";
    r13: my_pending_op.expiration > now otherwise "EXPIRED"
  }
  effect {
    pending_ops[the_op_id].approvals.add(caller);
  }
}

entry execute(
  the_op_id: nat
) {
  state is Running
  constant {
    my_pending_op ?is pending_ops[the_op_id] otherwise "INVALID OP ID"
  }
  require {
    r20: signers.contains(caller) otherwise "ONLY FOR SIGNERS";
    r21: length(my_pending_op.approvals) >= threshold otherwise "NOT YET APPROVED"
  }
  effect {
    operations := exec_lambda(pending_ops[the_op_id].actions, Unit);
    pending_ops.remove(the_op_id)
  }
}

entry archive_expired_operations(expired_op_ids: list<nat>) {
  state is Running
  require {
    r30: signers.contains(caller) otherwise "ONLY FOR SIGNERS"
  }
  effect {
    for expired_op_id in expired_op_ids do
      if (pending_ops[expired_op_id].expiration < now) then pending_ops.remove(expired_op_id)
      else fail("OP NOT YET EXPIRED")
    done
  }
}

view get_approvals(my_op_id: nat): set<address> {
  return match pending_ops[my_op_id] with | none -> make_set<address>([]) | some(v) -> v.approvals end
}
